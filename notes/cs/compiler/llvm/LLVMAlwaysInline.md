# LLVM Always Inline Pass

## always_inline这个attribute是否会自动内联其它inline函数

在 LLVM 中，`always_inline` 属性通常会促使优化器尽可能将函数内联到调用它的地方。然而，这个属性只直接作用于被标记为 `always_inline` 的函数。在你的例子中，`Foo` 函数被标记为 `always_inline`，所以它会尽可能被内联到调用它的地方。

对于 `Foo` 函数内部调用的其他函数，比如 `std::string` 的构造函数，`always_inline` 属性不会直接影响这些调用。是否内联 `std::string` 的构造函数取决于其他因素，比如编译器的优化设置、`std::string` 构造函数本身的内联属性以及编译器对代码的具体评估。

如果你想尽可能地进行优化，并希望内联更多的函数，你可以尝试使用更高的优化等级，比如使用 `-O2` 或 `-O3`。这些优化等级通常会尽量内联更多的函数以获得更高的性能，但是并不能保证一定会内联特定的函数。最终是否内联 `std::string` 的构造函数还是由编译器的优化决策来确定。
