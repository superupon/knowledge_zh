# 为什么要有LLVM :question:

## 1. 传统编译器的三阶段实现

![传统编译器](/picture/v2-93d57370430d6cc662379d40b4f5bcd3_720w.webp)

最流行的编译器的设计通常是三阶段设计。

分别由**前端**，**优化器**和**后端**组成。

* **前端**处理源代码，检查语法错误，对于输入的代码生成AST(抽象语法树)。抽象语法树可以被转换成一种新的用于优化的表示。
* **优化器**负责执行大量的转换，以提升代码的运行时，比如消除冗余的计算，它通常独立于语言和目标机器。
* **后端**会将代码映射成目标机器指令集。除了生成正确的机器码之外，它也负责利用所支持架构的不通用的特性来优化机器码。编译器后端一般包含指令选择，寄存器调度和指令调度。

这一经典的设计有什么好处呢？如果编译器的优化器部分采用一种统一的中间表示，那么前端可以支持任一可以生成该中间表示的语言。同样，后端也可以支持可以从该中间表示生成的目标架构。

在该设计下，实现一种新的语言的编译器，只需要提供一个前端就可以了，优化器和后端都不用变。而如果三个部分混杂在一起，那么，要支持N种架构的M种语言，就需要N*M个编译器。

其次，编译器前端和优化，以及后端，差异是非常大的。拆分成三个阶段也有助于各个阶段的人可以做各自擅长的事情。

多目标能力

![传统编译器](/picture/v2-b4b59d5c244abbb073628542e2dc63e9_720w.webp)

## 2. LLVM的三阶段实现

![传统编译器](/picture/v2-ea015d64b388f4a20c42bcc0a7cdca2c_720w.webp)

LLVM的三阶段实现

如上图所示，借助于LLVM IR， LLVM提供了它的[^1]。

在一个基于LLVM的编译器中，前端用于对输入代码进行解析，验证和诊断错误，并且生成LLVM IR. 而这些IR又会经过一系列可选的分析和转换pass（关于什么是pass, 我们随后会提供新的文章来描述）, 来优化LLVM IR。然后，LLVM IR被发送给后端以生成本机码。

## 3. LLVM IR （中间表示）初印象

什么是LLVM IR呢？它是LLVM框架提供的一种中间表示形式。

```cpp
void main() {
    int c1 = 17;
    int c2 = 25;
    int c3 = c1 + c2;
    printf("Value = %d\n", c3);
}
```

对应的LLVM IR形式如下：

![](/picture/v2-d0a40f4cb3ac59b8ea05dfe505ce656d_720w.webp)

这里可以先大致对其有个印象，后文我们再会详细的讲述这些IR分配代表什么意思。至于LLVM IR为什么会变成这样？有什么目的？那么，在后文中再慢慢道来。

## 4. LLVM IR在整个框架中的重要地位

从上面的三阶段图中就可以看出来，没有LLVM IR, 整个框架就根本不成立。它建立起了沟通编译器的前端和后端的桥梁。同时在它之上，还可以执行各式各样和平台无关的优化。

参考

[^1]: https://www.aosabook.org/en/llvm.html
